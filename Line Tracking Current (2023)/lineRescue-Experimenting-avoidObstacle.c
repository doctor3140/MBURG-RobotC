#pragma config(Sensor, S1,     leftS,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     rightS,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     reflect,        sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "\lib\teamTools.h"
#define FINDDIST 1
#define TURNDIST 3



/*
rightS is right;
leftS is left;
S4 is Sonar;
C is right;
B is left;

Errors:
1 - Unknown color
2 - Error in leanDetect while change = 0
3 - Error in leanDetect while change does not = 0
*/

//drives backwards right now 1/23/2023



/*

CHANGELOG!! 2/13/23

Rewrote #pragma code to syntax

*/


//variables for obstacle
float robotWidth = 13.6;
float robotLength = 17;
float maxObstacleSize = 14;
float obstacleDistance = 3; //the distance when it will see the obstacle in cm (confirm this)
float turnDistance= robotWidth/2;
bool hasObstacle = false;

//features
bool checkGreen = true; //to enable/disable lilCheck function
bool checkTurnFurther = false; //to enable/disable turning further when line not found
bool checkSonar = false; //to enable/disable checkObstacle function

bool LT = true;

bool checkObstacle(int x)
{	if (SensorValue[S4] < x)
	{
		return true;
	}
	else
	{
		return false;
	}
}
void avoidObstacle()
{
		//while((SensorValue[S4] >= obstacleDistance))
		//{
			//sleep(500)
			playTone();
			checkObstacle(obstacleDistance);

			if (hasObstacle == true)
			{
				LT = false; //hate this find better way
				STP();
				resetMotorEncoder(motorB);
				resetMotorEncoder(motorC);
				encoderBackward(turnDistance-obstacleDistance);
				STP();
				sleep(1000);
				encoderPointLeft();
				encoderForward(robotWidth);
				encoderPointRight();
				checkObstacle(obstacleDistance);


				resetMotorEncoder(motorB);
				resetMotorEncoder(motorC);

				encoderForward((obstacleDistance+robotLength)+(2*turnDistance));

				encoderPointRight();
				resetMotorEncoder(motorB);
				resetMotorEncoder(motorC);
					while((getColorName(leftS)==colorWhite)||(getColorName(leftS)==colorWhite)){
					motorForward(5);
					}
					sleep(500);
					encoderPointLeft();
					STP();
					sleep(500);
					LT = true;
				}
					hasObstacle = false;
					//startTask(main);

}
task display() //Display for Error Log
{
	repeat(forever){
	displayBigTextLine(2, "LCS: %d", getColorName(leftS));
	displayBigTextLine(4, "RCS: %d", getColorName(rightS));
	displayBigTextLine(6, "SS: %d", SensorValue[S4]);
	displayBigTextLine(8, "LeftM: %d", getMotorEncoder(leftMotor));
	displayBigTextLine(10, "RightM: %d", getMotorEncoder(rightMotor));
	sleep(20); //refreshrate in ms
	}
}


void findLineLeft()
{
	clearTimer(T1);
	//playSound(soundBlip);
	encoderForward(FINDDIST);
	while (time1[T1] < searchTime) //need to find better timing method/boot-out. Consult WindSprints for better bootout
	{
		if ((getColorName(rightS)==colorWhite)) //was right
		{
			motorSearchLeft();
			//startTask(display);
		}
		else if(getColorName(rightS)==colorBlack)
		{
			STP();
			sleep(200);

		}
	}

	while ((getColorName(leftS)!=colorBlack)) //change to ==white if no work (most likely redundent remove cmt after testing)
	{
		motorSearchRight();
	}
	STP();
}


void findLineRight()
{
	clearTimer(T1);
	encoderForward(FINDDIST);
	while (time1[T1] < searchTime) //need to find better timing method/boot-out. Consult WindSprints for better bootout
	{
		if ((getColorName(leftS)==colorWhite)) //was left
		{
			motorSearchRight();
			//startTask(display);
		}
		else if (getColorName(leftS)==colorBlack)
		{
			STP();
			sleep(200);
		}
	}
	while ((getColorName(rightS)!=colorBlack)) //change to ==white if no work (most likely redundent remove cmt after testing)
	{
		motorSearchLeft();
		//startTask(display);
	}
	STP();
}

	//this is awful, please fix


void leftTurn()
{
	STP();
	sleep(200); //was 500
	encoderForward(getTapeThreasholdCM());
	if (getColorName(leftS)==colorBlack) //was leftS, but since leftS is Right then it should be rightS nvm???
	{
		encoderForward(TURNDIST);
		encoderPointLeft();
		if(checkTurnFurther && (getColorName(leftS)==colorWhite)){
		findLineLeft();
		}
		encoderForward();
		sleep(20);
	}
	else{
		findLineRight();
	}
}

void rightTurn()
{
	STP();
	sleep(200);
	//playSound(soundBeepBeep);
	encoderForward(getTapeThreasholdCM()); //Turn off if momentum is too much
	if (getColorName(rightS)==colorBlack) //was rightS, but since rightS is Left then it should be leftS nvm???
	{
		playSound(soundBeepBeep);
		encoderForward(TURNDIST);
		encoderPointRight();
		if(checkTurnFurther && (getColorName(rightS)==colorWhite)){
		findLineRight();
		}
		encoderForward();
		sleep(20);
	}
	else{
		findLineLeft();
	}
}


//Turns left until sensor sees black or timer runs out and doubles back right
//made for double black and as fail safe when leanDetect fails


void lilCheck(bool leftIsTrue)
{
if(checkGreen){
	//setLEDColor(ledOrangePulse);
	STP();
	sleep(500);
	if(leftIsTrue) //true is left
	{
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
		//setMotorTarget(rightMotor, m*20, 10);
		//waitUntilMotorStop(rightMotor);
		setMotorTarget(rightMotor, m*10, 10);
		setMotorTarget(leftMotor, -m*10,10);
		waitUntilMotorStop(rightMotor);
		waitUntilMotorStop(leftMotor);
		if (getColorName(rightS)==colorGreen)
		{
			setMotorTarget(rightMotor, 0, 0); //Was motorC, but seemed to be moving wrong direction
			waitUntilMotorStop(rightMotor);
			STP();
			uTurn();
		}
		else
		{
			setMotorTarget(rightMotor, 0, 0);  //Was motorC, but seemed to be moving wrong direction (what is this do)
			waitUntilMotorStop(rightMotor);
			leftTurn();
		}
	}
	else
	{
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
		setMotorTarget(leftMotor, m*20, 10);
		waitUntilMotorStop(leftMotor);

		if (getColorName(leftS)==colorGreen)
		{
			setMotorTarget(leftMotor, 0, 0); //Was motorB, but seemed to be moving wrong direction
			waitUntilMotorStop(leftMotor);
			STP();
			uTurn();
		}
		else
		{
			setMotorTarget(leftMotor, 0, 0);
			waitUntilMotorStop(leftMotor);
			rightTurn();
		}
	}
}
}
